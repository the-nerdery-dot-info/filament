material {
    name : separableGaussianBlur,
    parameters : [
        {
            type : sampler2d,
            name : source,
            precision: medium
        },
        {
            type : float4,
            name : resolution,
            precision: high
        },
        {
            type : float2,
            name : axis
        },
        {
            type : int,
            name : level
        },
        {
            type : int,
            name : count
        },
        {
            type : float[15],
            name : samples
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = postProcess.normalizedUV * materialParams.resolution.xy;
    }
}

fragment {
    vec2 clampToEdge(const sampler2D s, vec2 uv) {
        vec2 size = textureSize(s, materialParams.level);
        return clamp(uv, vec2(0), size - vec2(1));
    }

    void tap(inout vec3 sum, inout float totalWeight, float weight, vec2 position) {
        position = clampToEdge(materialParams_source, position);
        vec3 texel = texelFetch(materialParams_source, ivec2(position), materialParams.level).rgb;
        sum += texel * weight;
        totalWeight += weight;
    }

    void postProcess(inout PostProcessInputs postProcess) {
        // in the fragment shader, this is interpolated to pixel centers, but since we use
        // texel-fetch, it's not what we want. Convert from screen uv to texture uv.
        vec2 size = textureSize(materialParams_source, materialParams.level);
        vec2 uv = floor(variable_vertex.xy) * (size * materialParams.resolution.zw);

        // we handle the center pixel separately
        float totalWeight = materialParams.samples[0];
        vec3 sum = texelFetch(materialParams_source, ivec2(uv), materialParams.level).rgb * totalWeight;

        vec2 offset = vec2(0);
        for (int i = 1; i < materialParams.count; i++, offset += materialParams.axis) {
            float weight = materialParams.samples[i];
            tap(sum, totalWeight, weight, uv + offset);
            tap(sum, totalWeight, weight, uv - offset);
        }

        postProcess.color.rgb = sum * (1.0 / totalWeight);
    }
}
