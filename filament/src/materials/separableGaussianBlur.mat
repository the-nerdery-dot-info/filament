material {
    name : separableGaussianBlur,
    parameters : [
        {
            type : sampler2d,
            name : source,
            precision: medium
        },
        {
            type : float4,
            name : resolution,
            precision: high
        },
        {
            type : int2,
            name : axis
        },
        {
            type : int,
            name : level
        },
        {
            type : int,
            name : count
        },
        {
            type : float[15],
            name : samples
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        // in the fragment shader, this is interpolated to pixel centers, but since we use
        // texel-fetch, it's not what we want. Convert from screen uv to texture uv.
        vec2 size = textureSize(materialParams_source, materialParams.level);
        //postProcess.vertex.xy = postProcess.normalizedUV * (size - 1.0 / size);
        postProcess.vertex.xy = postProcess.normalizedUV * size;
    }
}

fragment {
    ivec2 clampToEdge(const sampler2D s, ivec2 uv) {
        ivec2 size = textureSize(s, materialParams.level);
        return clamp(uv, ivec2(0), size - ivec2(1));
    }

    void tap(inout vec3 sum, inout float totalWeight, float weight, ivec2 position) {
        position = clampToEdge(materialParams_source, position);
        vec3 texel = texelFetch(materialParams_source, position, materialParams.level).rgb;
        sum += texel * weight;
        totalWeight += weight;
    }

    void postProcess(inout PostProcessInputs postProcess) {
        highp ivec2 uv = ivec2(floor(variable_vertex.xy));

        // we handle the center pixel separately
        float totalWeight = materialParams.samples[0];
        vec3 sum = texelFetch(materialParams_source, uv, materialParams.level).rgb * totalWeight;

        for (int i = 1; i < materialParams.count; i++) {
            float weight = materialParams.samples[i];
            ivec2 offset = i * materialParams.axis;
            tap(sum, totalWeight, weight, uv + offset);
            tap(sum, totalWeight, weight, uv - offset);
        }

        postProcess.color.rgb = sum * (1.0 / totalWeight);
    }
}
